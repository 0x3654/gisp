# **ГИСП реестр, API и Чат для поиска**

Поиск по реестру российской промышленной продукции Минпромторга в формате чата с автоматическим обновлением данных и возможностью интеграции с api.

`PostgreSQL` с готовой структурой, `FastAPI‑шлюз`, `семантический сервис` и чат-интерфейс на базе `OpenWebUI`.

`import` автоматически скачивает свежие CSV файлы каждую ночь, пишет логи, чистит старые файлы.

Вы получаете поиск двумя способами: строгие фильтры по параметрам и семантический режим поиска по наименованию с расширением синонимами — по умолчанию чат комбинирует оба источника и выводит результаты в едином списке. Подробности выбора режима описаны в разделе [Описание параметров в чате](#описание-параметров-в-чате).

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="docs/chat-dark.png">
  <source media="(prefers-color-scheme: light)" srcset="docs/chat-light.png">
  <img alt="Скриншот поиска в чате" src="docs/chat-light.png">
</picture>

**Требования**
- Docker Engine + Docker Compose Plugin (версия 2.20+) и Git, Ubuntu 20/Debian 12 и новее:
  ```bash
  sudo apt update
  sudo apt install -y docker.io docker-compose-plugin git
  sudo usermod -aG docker "$USER"
  ```
- 6 ГБ RAM (8 ГБ рекомендовано) и ~6-10 ГБ свободного диска (образы ≈ 3 ГБ, модель ≈ 1 ГБ; стартовый snapshot временно скачивается отдельным контейнером.

# Быстрый старт

Выполните bootstrap-скрипт (скачивает ~3 ГБ образов и ~1 ГБ данных, останавливается при любой ошибке):

```bash
curl -fsSL https://raw.githubusercontent.com/0x3654/gisp/master/scripts/bootstrap.sh | bash
```

Скрипт установит Docker/Compose/Git, клонирует репозиторий, подготовит конфиги, загрузит стартовый дамп через `starter-dump` и запустит контейнеры `postgres_registry`, `api`, `import`, `semantic`, `openwebui`. После завершения откройте http://localhost:3333 admin@gisp.ru 123

# **Установка**

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/0x3654/gisp.git
   cd gisp
   ```
2. Создайте локальные конфиги из примеров:
   ```bash
   cp .env.example .env
   cp services/semantic/synonyms.example.json services/semantic/synonyms.json
   ```
3. Заполните `.env` реальными значениями:
   - `REGISTRY_NODE_NAME` — подпись сервера в уведомлениях (если не задать, будет короткий ID контейнера).
   - `BOT_TOKEN`/`CHAT_ID` — опциональные параметры для уведомлений Telegram.
   - Остальные параметры можно оставить как есть:
     - `POSTGRES_*` — креды PostgreSQL (используются API, импортером и воркерами).
     - `FILES_DIR`, `LOG_DIR`, `MAX_*` — каталоги и политики очистки для контейнера `import`.
     - `SEMANTIC_CACHE_TTL_SECONDS` — сколько хранить кэш запросов семантического сервиса (по умолчанию 7 суток в секундах).

4. *(опционально)* Отредактируйте `services/semantic/synonyms.json`, добавив свои пары «термин → список синонимов»:
   ```json
   {
     "сода": [
       "гидрокарбонат натрия",
       "пищевая сода"
     ]
   }
   ```
5. *(опционально)* Подготовьте шаблон БД для OpenWebUI:
   ```bash
   mkdir -p services/openwebui/data
   cp services/openwebui/webui.db.example services/openwebui/data/webui.db
   ```

    Users:
    - admin@gisp.ru 123
    - gisp@gisp.ru 123

6. *(опционально)* Загрузите стартовый дамп через `starter-dump`:
   ```bash
   COMPOSE_PROFILES=starter docker compose run -T --rm starter-dump
   ```
   Загрузит ~531K записей реестра + векторные эмбеддинги (~902MB сжато; на дату: 06.02.2025).

7. Запустите стек:
   ```bash
   docker compose up -d --build postgres_registry api import semantic openwebui
   ```

# **Структура проекта**

Контейнеры и их Dockerfile'ы лежат в каталоге `services/<name>` (api, import, semantic, openwebui и т.д.).
<!-- Схема обработки сообщений и взаимодействия с API (Excalidraw): см. файл docs/workflow.excalidraw -->

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="docs/scheme-dark.png">
  <source media="(prefers-color-scheme: light)" srcset="docs/scheme-light.png">
  <img alt="Схема сервисов" src="docs/chat-light.png">
</picture>

> ## **Контейнер postgres_registry**
> PostgreSQL с расширением pgvector. Хранит:
> - `registry.reestr` — нормализованные записи реестра (полный набор полей Минпромторга);
> - `registry.load_log` — журнал загрузок CSV;
> - `registry.semantic_items` — кэш эмбеддингов (reestr_id + вектор);
> - `registry.semantic_query_cache` — кэш запросов чата за последние 7 дней (парамертр `SEMANTIC_CACHE_TTL_SECONDS`).

> ## **Контейнер api**
> FastAPI-шлюз для REST-запросов и выдачи данных с обрабатывает запросы с фильтрами и семантические запросы.

> ## **Контейнер import**
> Фоновый импортёр: при старте контейнера и по расписанию скачивает CSV, нормализует данные и заливает в базу. Внутри контейнера настроен cron: в 00:05 ежедневно выполняется `run_import.sh`, в 05:00 — `run_pg_maintenance.sh`
>
> При необходимости можно запустить импорт вручную:
> ```bash
> docker compose run --rm import /scripts/run_import.sh
> ```
> После успешной загрузки, если `AUTO_EMBED=1`, контейнер вызовет embeddings-worker и обновит эмбеддинги для новых записей.
> Уведомления о статусе импортов отправляются в Telegram (если заданы `BOT_TOKEN`/`CHAT_ID`).

> ## **Контейнер semantic**
> FastAPI-шлюз для REST-запросов строит эмбеддинги и расширяет запросы с учетом `synonyms.json`. В образ сразу добавлена модель `paraphrase-multilingual-MiniLM-L12-v2`.

> ## **Контейнер embeddings-worker**
> Одноразовый воркер для массового пересчёта эмбеддингов. Стартует по команде `docker compose run --rm embeddings-worker`, поддерживает шардирование и форс-пересчёт через переменные окружения.

> ## **Контейнеры openwebui**
> WebUI для общения с системой в формате чата.

> ## **Контейнер starter-dump**
> Одноразовый образ для первичной инициализации БД стартовым снепшотом.
>
> **Когда запускать:**
> - При первой установке на пустую БД
> - Для восстановления данных после сбоя
> - При обновлении до свежего снепшота
>
> **Запуск:**
> ```bash
> COMPOSE_PROFILES=starter docker compose run -T --rm starter-dump
> ```
>
> **Переменные окружения:**
> - `STARTER_FORCE=0` — (по умолчанию) пропустить восстановление если в `registry.reestr` есть данные
> - `STARTER_FORCE=1` — принудительно перезаписать данные (используйте с осторожностью!)
> - `STARTER_MAX_WAIT=180` — макс. время ожидания PostgreSQL (секунды)
>
> **Что содержит снепшот:**
> - ✅ `registry.reestr` — записи реестра (~531K строк, ~902MB сжато)
> - ✅ `registry.semantic_items` — векторные эмбеддинги для семантического поиска
> - ❌ `registry.load_log` — история загрузок (не сохраняется)
> - ❌ `registry.semantic_query_cache` — кеш запросов (восстановится сам)
>
> **Примечание:** Сервис запускается один раз, выполняет восстановление и завершается с кодом 0.

# I. **FastAPI Web API**
<details>
<summary><b>Описание:</b></summary>
> ### Эндпоинт: GET `/reestr`

> Параметры запроса:
> | Параметр      | Тип    | Описание                                                                 |
> |---------------|--------|--------------------------------------------------------------------------|
> | `inn`         | `str`  | ИНН организации|
> | `tnved`       | `str`  | Код ТНВЭД|
> | `okpd2`       | `str`  | Код ОКПД2                                                              |
> | `productname` | `str`  | Наименование продукта, поддержка `$` для обязательных терминов и `^` для альтернативных |
> | `regnumber`   | `str`  | Регистрационный номер, формат "244\4\2023"                            |
> | `nameoforg`   | `str`  | Название организации.                                                   |
> | `code`        | `str`  | Универсальный код, ищет и по ИНН, и по ТНВЭД                         |
> | `limit`       | `int`  | Количество записей (по умолчанию 20, максимум 200 — регулируется `REESTR_*` в `.env`) |
> | `offset`      | `int`  | Смещение (по умолчанию 0, неотрицательное)                             |


 ---

> **Описание работы:**
> - Формирует SQL-запрос с фильтрами по переданным параметрам
> - Параметр `code` ищется и по ИНН, и по ТНВЭД
> - Параметр `productname` разбивается по `$` (все термины должны присутствовать) и `^` (любой из вариантов), каждая часть ищется через `ILIKE`
> - Параметр `regnumber` нормализуется (обратный слэш)
> - Результат ограничивается параметрами `limit` и `offset`

> **Возвращаемый JSON:**
> ```json
> {
>   "rows": [...],
>   "limit": 20,
>   "offset": 0,
>   "count": 20
> }
> ```


---

> ### Эндпоинт: GET `/reestr/semantic`

> Параметры запроса:
> | Параметр    | Тип   | Описание |
> |-------------|-------|----------|
> | `text`      | `str` (**обязателен**) | Свободный запрос пользователя, тот же текст, что вводится в чат (`semantic|…`) |
> | `limit`     | `int` | Количество записей (1–100, по умолчанию 10) |
> | `offset`    | `int` | Смещение результата (>=0) |
> | `inn` / `tnved` / `okpd2` / `regnumber` / `nameoforg` / `code` | как в `/reestr` | Дополнительные фильтры, применяются после семантического ранжирования |


---

> **Описание работы:**
> - API запрашивает embedding у контейнера `semantic`, где запрос очищается, нормализуется и расширяется синонимами из `services/semantic/synonyms.json`.
> - Выполняется прогрессивный поиск по таблице `registry.semantic_items` с fallback-листом:
>   - Начальное ограничение `limit*2`, затем (если результатов мало) лимит удваивается до 800 строк.
>   - При необходимости TНВЭД «усекается» (10→8→6→4) или полностью отключается, чтобы избежать пустых выборок.
> - Результаты агрегируются с учётом наложенных фильтров (`inn`, `okpd2`, …) и сортируются по косинусной дистанции (`embedding <=> query`).
> - Повторные запросы к одному и тому же тексту берут embedding из кэша PostgreSQL (`registry.semantic_query_cache`, TTL задаётся `SEMANTIC_CACHE_TTL_SECONDS`).

> **Возвращаемый JSON (сокращённо):**
> ```json
> {
>   "rows": [
>     {
>       "productname": "...",
>       "distance": 0.1372,
>       "token_matches": 5,
>       "...": "..."
>     }
>   ],
>   "limit": 10,
>   "offset": 0,
>   "count": 10,
>   "semantic": {
>     "original_query": "Сода пищевая 500гр.*24",
>     "normalized_query": "сода пищевая 500гр 24",
>     "synonyms": ["гидрокарбонат натрия"],
>     "tokens": ["сода", "пищевая", "500гр", "*24"],
>     "fallback_attempts": [
>       {"label": "original", "rows": 20, "limit_used": 20, "elapsed": 1.2}
>     ],
>     "fallback_used": false,
>     "active_filters": {
>       "inn": null,
>       "tnved": null,
>       "okpd2": null,
>       "regnumber": null,
>       "code": null
>     }
>   }
> }
> ```
</details>

---

# II. Обработка сообщений в чате
<details>
<summary><b>Описание:</b></summary>

> 1. **Получение текста**
>  - Метод [`pipe()`](#pipebody-dict) берёт список сообщений из `body["messages"]`
>   - Извлекается последнее сообщение пользователя с ролью `role="user"`
>   - Текст сообщения сохраняется в переменную `text`

>2. **Определение флагов управления**
>   - Проверяется, включён ли `debug` ([`_extract_debug_flag`](#_extract_debug_flagtext)) — для вывода отладки
>   - Определяется `max_rows` ([`_extract_max_rows`](#_extract_max_rowstext)) — максимальное количество строк для вывода
>   - Из текста удаляются строки управления (`debug`, `max_rows`) через [`clean_control_params`](#clean_control_paramstext)
>   - Удаляются строки с ключевыми словами и ссылками через [`_strip_debug_lines`](#_strip_debug_lines)

>3. **Извлечение явных параметров**
>   - Метод [`_extract_explicit`](#_extract_explicittext) ищет в тексте:
>     - `INN` (`инн`, `inn`)
>     - `TNVED` (`tnved`, `тнвэд`, `тнвед`)
>     - `OKPD2` (`okpd2`, `окпд2`)
>     - `REGNUMBER` (`regnumber`, `регномер`)
>     - Наименование продукта (`productname`, `товар`, `наименование`)
>   - Найденные значения сразу добавляются в словарь `params`

>4. **Очистка текста**
>   - Из текста удаляются все ключи из `ALL_KEYS` и их варианты (например, слова "инн", "tnved", "окпд2" и т.п.), чтобы они не попали в `productname`
>   - `OKPD2` также вырезается из текста до формирования `productname`

>5. **Формирование параметров поиска**
>   - Если явного `productname` нет — оставшийся текст после удаления ключей и чисел берётся как `productname`
>   - Определяются кандидаты для:
>     - `inn` — числа 10–12 цифр с проверкой контрольной суммы
>     - `tnved` — числа 4, 6, 8, 10 цифр, которые не подошли как `INN`
>   - Если найден один 10-значный код — он используется как `code`, и `inn`/`tnved` не добавляются
>   - Если найден только `INN` или только `TNVED` — создаётся `code` с удалением исходных `inn`/`tnved`
>   - Итоговые параметры сохраняются в `params`, добавляются `max_rows` и флаг `debug`

>6. **Подготовка запроса к API**
>   - В `params_to_send` помещаются только найденные параметры: `code`, `inn`, `tnved`, `okpd2`, `productname`, `regnumber`
>   - Строки и списки объединяются через `|` для передачи нескольких значений

>7. **Отправка запроса и fallback**
>   - Первый запрос к API отправляется с текущими `params_to_send
>   - Если ничего не найдено:
>     1. Если есть `code`, он считается как `TNVED`, и пробуются сокращения TNVED 10→8→6→4
>     2. Если есть `TNVED`, пробуются сокращения TNVED 8→6→4
>   - Все попытки и результаты сохраняются в `fallback_debug` для отображения в отладке

>8. **Формирование ответа**
>   - Результат API нормализуется через [`_normalize_rows`](#_normalize_rowspayload) (список словарей и мета-информация)
>   - Таблица формируется через [`_format_table`](#_format_tablerows-meta-max_rows):
>     - Заголовки столбцов переименовываются через `FIELD_RENAME`
>     - Даты (`docdate`, `docvalidtill`) приводятся к формату `DD.MM.YYYY`
>   - Если результатов нет — выводится сообщение:
>     > "Ничего не найдено по заданным критериям."
>   - Если включён `debug`, возвращается блок с:
>     - Перечнем fallback-попыток
>     - Итоговыми параметрами запроса
>   - Иначе возвращается только таблица с результатами

>9. **Дополнительные операции**
>   - Разделение `productname`: `$` — логическое И, `^` — логическое ИЛИ
>   - Проверка корректности ИНН
>   - Нормализация регистрационных номеров
>   - Очистка лишних символов и переносов из текста
</details>

# III. Chat Pipe (`reestr_openwebui.py`)

<details>
<summary><b>Описание:</b></summary>

>Класс `Pipe` обрабатывает текстовые сообщения и подготавливает параметры для API

### Методы

#### `_detect_data_type(text: str) -> dict`
>- Извлекает параметры: `inn`, `tnved`, `okpd2`, `regnumber`, `productname`, `code`
>- Распознаёт `OKPD2` до формирования `productname`
>- Если найден единичный 10-значный код — он считается `code`
>- Формирует итоговый словарь `params` с флагом `debug` и параметром `max_rows`

#### `pipe(body: dict)`

>- Основной метод обработки сообщений
>- Парсит текст пользователя
>- Выполняет запрос к API (`/reestr`)
>- Реализует fallback: преобразование `code` в `tnved` с сокращениями (10→8→6→4), а также сокращения TNVED (8→6→4)
>- Возвращает Markdown-таблицу с переименованными заголовками (`FIELD_RENAME`)
>- При включённом `debug` выводит все попытки fallback и параметры запроса
>- Команда `semantic|…` (или `сима`) выполняет поиск ближайших наименований по эмбеддингам:
>  - текст кодируется «как есть», затем расширяется синонимами (например, «сода пищевая» → «гидрокарбонат натрия») из `services/semantic/synonyms.json`;
>  - результаты ранжируются по количеству совпавших токенов и косинусной дистанции;
>  - строки без совпадений по токенам отбрасываются для предсказуемой выдачи.
>  Используется лёгкая лингвистическая модель на CPU — ответы приходят быстро, без участия LLM и без требований к GPU.

</details>

### Описание параметров в чате

По умолчанию Pipe сначала строит фильтры и обращается к `/reestr`; семантика подключается только если остаётся «лишний» текст или если пользователь явно набрал `semantic|`.

**Чтобы выполнить запрос с строгим соответствием:**
- задавайте параметры в явном виде (каждая пара "параметр: значение" на новой строке или через пробел):
  - `inn:` / `инн:`
  - `tnved:` / `тнвед:` / `тнвэд:` / `тн вэд:`
  - `okpd2:` / `окпд2:`
  - `regnumber:` / `регномер:` / `регистрационный номер:`
  - `productname:` / `product:` / `name:` / `товар:` / `продукт:` / `наименование:` / `артикул:`
  - `nameoforg:` / `организация:` / `organization:`
  - `code:` (универсальный код для INN или TNVED)
  - `semantic|` (для чистого семантического режима);
  - `сравни` — отдельный режим семантического сравнения; работает в двух вариантах:
    - две строки: `сравни\nстрока1\nстрока2` — вернёт дистанцию и нормализацию обеих строк;
    - одна строка + список вариантов: первая строка после команды считается «исходной», остальные — кандидаты; Pipe подберёт наиболее похожий вариант из списка, отсортирует остальные по сходству и выведет таблицу с дистанциями и нормализованными значениями. По умолчанию показывается топ‑10, но можно добавить `max: 20` (или другое значение до 1000), чтобы увидеть больше или всю таблицу. Флаги `--debug`/`--nodebug` также поддерживаются.
  пример: `inn:6617025849 tnved:340220 productname:"сода кальцинированная"`;
- или используйте формат `regnumber:1257\16\2023` / `code:6617025849` — наличие `regnumber` всегда отключает семантический блок;

**Дополнительные управляющие слова:**
  - `debug:on` / `debug` — включает краткий блок «Отладка (кратко)» с последними фильтрами и fallback’ами;
  - `debug:full` — добавляет JSON-ответ API/семантики целиком;
  - `debug:summary` / `debug short` — выводит только текстовое резюме без JSON;
  - `debug:off` — принудительно скрывает отладку даже если она включена по умолчанию;
  - `max:20` / `rows:50` — задаёт количество строк в таблице (аналог `limit`);
  - `semantic|` (`семантик|`, `сима|`) — принудительно запускает только семантический поиск.
  - `сравни` — сравнивает строки: либо одна пара, либо одна строка + список вариантов. Можно быстро проверить, какой признак/название ближе к исходному.



##### **Словарь синонимов**
- Расположен в `services/semantic/synonyms.json` и содержит пары вида `"ключевое слово": ["вариант1", "вариант2"]`.
- Храните ключи и значения в нижнем регистре, чтобы совпадения учитывались независимо от исходного написания.
- После правок пересоберите `semantic` (`docker compose build semantic && docker compose up -d semantic`), чтобы обновить кэш модели.
- OpenWebUI автоматически подхватит новые синонимы: дополнительные запросы (например, «сода» → «гидрокарбонат натрия») пойдут в работу сразу после пересборки контейнера.

#### `_format_table(rows, meta, max_rows)`

> - Формирует таблицу в формате Markdown
> - Заголовки столбцов переименовываются с помощью `FIELD_RENAME`
> - Даты (`docdate` и `docvalidtill`) форматируются в `DD.MM.YYYY`

#### `_normalize_rows(payload)`

> - Преобразует ответ API в список словарей и мета-информацию

#### `_extract_explicit(text)`

> - Извлекает явные параметры из текста:
>   - `INN` (`инн`, `inn`)
>   - `TNVED` (`tnved`, `тнвэд`, `тнвед`)
>   - `OKPD2` (`okpd2`, `окпд2`)
>   - `REGNUMBER` (`regnumber`, `регномер`)
>   - Наименование продукта (`productname`, `товар`, `наименование`)
>   - `Nameoforg` (`nameoforg`, `организация`, `organization` и др.)
> - Возвращает кортеж `(params, очищенный_текст)`:
>   - `params` — словарь найденных значений
>   - `очищенный_текст` — исходный текст без явно распознанных фрагментов, используется для дальнейшего анализа

#### `_extract_debug_flag(text)`

> - Определяет, включён ли режим `debug`

#### `_extract_max_rows(text)`

> - Определяет параметр `max_rows`

#### `clean_control_params(text)`

>- Удаляет строки управления `debug` и `max_rows` из текста

#### `split_terms(value)`

> - Хелпер из API: делит значение `productname` по разделителям `$` (логическое И) и `^` (логическое ИЛИ), удаляя лишние пробелы

#### `_validate_inn(inn_str)`

> - Проверяет корректность ИНН (10 или 12 цифр)

---
