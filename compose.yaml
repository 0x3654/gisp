name: registry
services:
  postgres_registry:
    image: docker.io/pgvector/pgvector:pg16
    container_name: gisp_pg
    shm_size: ${PG_SHM_SIZE:-2g}
    env_file: .env
    command: >
      postgres
      -c shared_preload_libraries=pg_prewarm
      -c pg_prewarm.autoprewarm=on
      -c pg_prewarm.autoprewarm_interval=${PG_AUTOPREWARM_INTERVAL:-120}
      -c pg_prewarm.autoprewarm_startup=on
    ports:
      - '${POSTGRES_PORT:-5432}:5432'
    volumes:
      - ./services/postgres/data:/var/lib/postgresql/data
      - ./services/init:/docker-entrypoint-initdb.d:ro
    healthcheck:
      test:
        - CMD-SHELL
        - pg_isready -U postgres -h 127.0.0.1
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    networks:
       - internal
       - default
  api:
    build:
      context: .
      dockerfile: src/api/Dockerfile
    image: docker.io/0x3654/gisp-api:latest
    container_name: gisp_api
    env_file: .env
    environment:
      - TZ=${TZ:-Europe/Moscow}
      - API_PORT=${API_PORT:-8000}
    ports:
      - '${API_PORT:-8000}:8000'
    depends_on:
      postgres_registry:
        condition: service_healthy
    healthcheck:
      test:
        - CMD-SHELL
        - python
        - -c
        - |
          import urllib.request, sys, os
          try:
              port = os.getenv('API_PORT', '8000')
              urllib.request.urlopen(f"http://127.0.0.1:{port}/docs", timeout=5)
          except Exception:
              sys.exit(1)
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    networks:
        - internal
  import:
    image: docker.io/0x3654/gisp-import:latest
    container_name: gisp_import
    env_file: .env
    environment:
      - TZ=${TZ:-Europe/Moscow}  # Container timezone (cron uses this for schedule)
      - POSTGRES_HOST=postgres_registry
      - POSTGRES_USER=${POSTGRES_USER:-postgres}
      # Cron schedule format: minute hour day month dow (uses $TZ above)
      - CRON_IMPORT_SCHEDULE=${CRON_IMPORT_SCHEDULE:-5 0 * * *}  # Daily at 00:05 Moscow time
      - CRON_MAINTENANCE_SCHEDULE=${CRON_MAINTENANCE_SCHEDULE:-0 5 * * *}  # Daily at 05:00 Moscow time
    volumes:
      - ./logs:/var/log/registry
      - ./services/import:/import
      - ./files:/files:cached
    depends_on:
      postgres_registry:
        condition: service_healthy
      semantic:
        condition: service_healthy
    healthcheck:
      test:
        - CMD-SHELL
        - pg_isready -h postgres_registry -U ${POSTGRES_USER:-postgres} && pidof crond >/dev/null
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    networks:
      - internal
      - default
  openwebui:
    image: ghcr.io/open-webui/open-webui
    container_name: gisp_openwebui
    ports:
      - '${OPENWEBUI_PORT:-3333}:8080'
    volumes:
      - ./services/openwebui/data:/app/backend/data
    healthcheck:
      test:
        - CMD-SHELL
        - python
        - -c
        - |
          import urllib.request, sys
          url = "http://127.0.0.1:8080/health"
          try:
              urllib.request.urlopen(url, timeout=5)
          except Exception:
              sys.exit(1)
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 90s
    restart: unless-stopped
    networks:
      - internal
      - default
  openwebui-sync:
    build:
      context: .
      dockerfile: src/openwebui/Dockerfile
    container_name: gisp_openwebui-sync
    profiles: ["tools"]
    volumes:
      # Only data volume needed - code is in image
      - ./services/openwebui/data:/data
    working_dir: /app
    entrypoint:
      - python
      - /app/reestr_sync.py
      - --db
      - /data/webui.db
      - --function-id
      - reestr
    depends_on:
      - openwebui
    restart: "no"

  # Semantic service (sentence embeddings)
  # По умолчанию использует gisp-semantic-onnx (оптимально для обеих архитектур)
  # Для переключения на PyTorch замените image: на docker.io/0x3654/gisp-semantic-pytorch:latest
  # Бенчмарки Python 3.12 + pymorphy3:
  # - AMD64 ONNX: ~1.03GB, 27-32ms (рекомендуется)
  # - AMD64 PyTorch: ~1.93GB, 28-35ms
  # - ARM64 ONNX: ~1.69GB, 37-44ms (рекомендуется)
  # - ARM64 PyTorch: ~2.46GB, 104-186ms
  semantic:
    image: docker.io/0x3654/gisp-semantic-onnx:latest
    container_name: gisp_semantic_service
    env_file: .env
    environment:
      - PYTHONPATH=/app
      - TZ=${TZ:-Europe/Moscow}
      - SEMANTIC_PORT=${SEMANTIC_PORT:-8010}
    volumes:
      - ./services/semantic/synonyms.json:/app/synonyms.json:ro
    command:
      - python
      - -m
      - uvicorn
      - semantic_service:app
      - --host
      - 0.0.0.0
      - --port
      - "${SEMANTIC_PORT:-8010}"
      - --workers
      - "${SEMANTIC_WORKERS:-2}"
    healthcheck:
      test:
        - CMD-SHELL
        - python
        - -c
        - |
          import socket, sys, os
          try:
              port = int(os.getenv('SEMANTIC_PORT', '8010'))
              s = socket.socket()
              s.connect(("127.0.0.1", port))
              s.close()
          except Exception:
              sys.exit(1)
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    depends_on:
      postgres_registry:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - internal
  embeddings-worker:
    image: docker.io/0x3654/gisp-semantic-onnx:latest
    profiles:
      - embeddings
    env_file: .env
    working_dir: /app
    volumes:
      - .:/app
    depends_on:
      - postgres_registry
      - semantic
    networks:
      - internal
    restart: "no"
    environment:
      FORCE: ${FORCE:-0}
      DRY_RUN: ${DRY_RUN:-0}
      SOURCE_FILES: ${SOURCE_FILES:-}
      EMBED_IDS: ${EMBED_IDS:-}
      LIMIT: ${LIMIT:-}
      EXTRA_EMBED_ARGS: ${EXTRA_EMBED_ARGS:-}
      SEMANTIC_URL_OVERRIDE: ${SEMANTIC_URL_OVERRIDE:-}
      SHARD_INDEX: "0"
      SHARD_COUNT: "1"
      BATCH_SIZE: "200"
    command: >
      bash -lc "set -e;
      ./services/import/scripts/run_embeddings_worker.sh"
    deploy:
      restart_policy:
        condition: none
  starter-dump:
    image: docker.io/0x3654/gisp-starter:latest
    container_name: gisp_starter_dump
    profiles:
      - starter
    env_file: .env
    environment:
      - SNAPSHOT_PATH=/app/registry_start_snapshot.sql.gz
      - STARTER_MAX_WAIT=180
      - FORCE=${STARTER_FORCE:-0}
      - POSTGRES_HOST=postgres_registry
      - POSTGRES_PORT=5432
      - POSTGRES_DB=registry
      - POSTGRES_USER=registry
    depends_on:
      - postgres_registry
    restart: "no"
    networks:
      - internal
networks:
   internal:
     internal: true
   default:
    name: registry-net
    driver: bridge
